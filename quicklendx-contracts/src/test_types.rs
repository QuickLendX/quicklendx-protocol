//! Comprehensive tests for all types defined in the `types` module.
//!
//! Covers every type in `types.rs`:
//! - **Enums**: `InvoiceStatus`, `BidStatus`, `InvestmentStatus`, `DisputeStatus`,
//!   `InvoiceCategory`
//! - **Structs**: `LineItemRecord`, `InvoiceMetadata`, `PaymentRecord`, `Dispute`,
//!   `InvoiceRating`, `Invoice`, `Bid`, `InsuranceCoverage`, `Investment`,
//!   `PlatformFee`, `PlatformFeeConfig`
//!
//! Each type is tested for:
//! - All variant / field construction and field-level assertions
//! - `Clone` correctness
//! - `PartialEq` / `Eq` (equality and inequality)
//! - Soroban serialization round-trip via `IntoVal` / `TryFromVal`
//!   (exercises the XDR encoding generated by `#[contracttype]`)
//! - Edge cases: zero values, maximum values, empty collections, large collections

use soroban_sdk::{
    testutils::Address as _, Address, BytesN, Env, IntoVal, String, TryFromVal, Val, Vec,
};

use crate::types::{
    Bid, BidStatus, Dispute, DisputeStatus, InsuranceCoverage, Investment, InvestmentStatus,
    Invoice, InvoiceCategory, InvoiceMetadata, InvoiceRating, InvoiceStatus, LineItemRecord,
    PaymentRecord, PlatformFee, PlatformFeeConfig,
};

// ============================================================================
// Shared helpers
// ============================================================================

/// Build a minimal, valid `Dispute` for use inside other structs.
fn make_dispute(env: &Env) -> Dispute {
    Dispute {
        created_by: Address::generate(env),
        created_at: 0,
        reason: String::from_str(env, ""),
        evidence: String::from_str(env, ""),
        resolution: String::from_str(env, ""),
        resolved_by: Address::generate(env),
        resolved_at: 0,
    }
}

/// Build a minimal, valid `InvoiceMetadata`.
fn make_metadata(env: &Env) -> InvoiceMetadata {
    InvoiceMetadata {
        customer_name: String::from_str(env, "Test Corp"),
        customer_address: String::from_str(env, "1 Test St"),
        tax_id: String::from_str(env, "TAX-001"),
        line_items: Vec::new(env),
        notes: String::from_str(env, ""),
    }
}

/// Build a minimal, valid `Invoice`.
fn make_invoice(env: &Env) -> Invoice {
    Invoice {
        id: BytesN::from_array(env, &[1u8; 32]),
        business: Address::generate(env),
        amount: 10_000,
        currency: Address::generate(env),
        due_date: 1_800_000_000,
        status: InvoiceStatus::Pending,
        description: String::from_str(env, "Test invoice"),
        category: InvoiceCategory::Services,
        tags: Vec::new(env),
        metadata: make_metadata(env),
        dispute: make_dispute(env),
        payments: Vec::new(env),
        ratings: Vec::new(env),
        created_at: 1_700_000_000,
        updated_at: 1_700_000_000,
    }
}

/// Build a minimal, valid `Bid`.
fn make_bid(env: &Env) -> Bid {
    Bid {
        bid_id: BytesN::from_array(env, &[2u8; 32]),
        invoice_id: BytesN::from_array(env, &[1u8; 32]),
        investor: Address::generate(env),
        bid_amount: 9_000,
        expected_return: 9_500,
        timestamp: 1_700_000_000,
        status: BidStatus::Placed,
        expiration_timestamp: 1_700_000_000 + 7 * 24 * 60 * 60,
    }
}

/// Build a minimal, valid `InsuranceCoverage`.
fn make_coverage(env: &Env) -> InsuranceCoverage {
    InsuranceCoverage {
        provider: Address::generate(env),
        coverage_amount: 8_000,
        premium_amount: 160,
        coverage_percentage: 80,
        active: true,
    }
}

/// Build a minimal, valid `Investment`.
fn make_investment(env: &Env) -> Investment {
    Investment {
        investment_id: BytesN::from_array(env, &[3u8; 32]),
        invoice_id: BytesN::from_array(env, &[1u8; 32]),
        investor: Address::generate(env),
        amount: 9_000,
        funded_at: 1_700_000_000,
        status: InvestmentStatus::Active,
        insurance: Vec::new(env),
    }
}

/// Build a `PlatformFee` with the given basis-points value.
fn make_fee(env: &Env, bps: u32, label: &str) -> PlatformFee {
    PlatformFee {
        fee_bps: bps,
        recipient: Address::generate(env),
        description: String::from_str(env, label),
    }
}

/// Build a full `PlatformFeeConfig`.
fn make_fee_config(env: &Env) -> PlatformFeeConfig {
    PlatformFeeConfig {
        verification_fee: make_fee(env, 25, "Verification"),
        settlement_fee: make_fee(env, 50, "Settlement"),
        bid_fee: make_fee(env, 10, "Bid"),
        investment_fee: make_fee(env, 20, "Investment"),
    }
}

/// Helper: assert a `#[contracttype]` value survives an XDR round-trip.
macro_rules! assert_roundtrip {
    ($env:expr, $val:expr, $T:ty) => {{
        let val: Val = ($val).clone().into_val($env);
        let recovered = <$T>::try_from_val($env, &val).unwrap();
        assert_eq!(($val).clone(), recovered);
    }};
}

// ============================================================================
// InvoiceStatus
// ============================================================================

#[test]
fn test_invoice_status_all_variants_distinct() {
    let all = [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b, "variant {i} should equal itself");
            } else {
                assert_ne!(a, b, "variants {i} and {j} should differ");
            }
        }
    }
}

#[test]
fn test_invoice_status_clone() {
    for status in [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_invoice_status_discriminants() {
    assert_eq!(InvoiceStatus::Pending as u8, 0);
    assert_eq!(InvoiceStatus::Verified as u8, 1);
    assert_eq!(InvoiceStatus::Funded as u8, 2);
    assert_eq!(InvoiceStatus::Paid as u8, 3);
    assert_eq!(InvoiceStatus::Defaulted as u8, 4);
    assert_eq!(InvoiceStatus::Cancelled as u8, 5);
}

#[test]
fn test_invoice_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ] {
        assert_roundtrip!(&env, status, InvoiceStatus);
    }
}

// ============================================================================
// BidStatus
// ============================================================================

#[test]
fn test_bid_status_all_variants_distinct() {
    let all = [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_bid_status_clone() {
    for status in [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_bid_status_discriminants() {
    assert_eq!(BidStatus::Placed as u8, 0);
    assert_eq!(BidStatus::Withdrawn as u8, 1);
    assert_eq!(BidStatus::Accepted as u8, 2);
    assert_eq!(BidStatus::Expired as u8, 3);
}

#[test]
fn test_bid_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ] {
        assert_roundtrip!(&env, status, BidStatus);
    }
}

// ============================================================================
// InvestmentStatus
// ============================================================================

#[test]
fn test_investment_status_all_variants_distinct() {
    let all = [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_investment_status_clone() {
    for status in [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_investment_status_discriminants() {
    assert_eq!(InvestmentStatus::Active as u8, 0);
    assert_eq!(InvestmentStatus::Withdrawn as u8, 1);
    assert_eq!(InvestmentStatus::Completed as u8, 2);
    assert_eq!(InvestmentStatus::Defaulted as u8, 3);
}

#[test]
fn test_investment_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ] {
        assert_roundtrip!(&env, status, InvestmentStatus);
    }
}

// ============================================================================
// DisputeStatus
// ============================================================================

#[test]
fn test_dispute_status_all_variants_distinct() {
    let all = [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_dispute_status_clone() {
    for status in [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_dispute_status_discriminants() {
    assert_eq!(DisputeStatus::None as u8, 0);
    assert_eq!(DisputeStatus::Disputed as u8, 1);
    assert_eq!(DisputeStatus::UnderReview as u8, 2);
    assert_eq!(DisputeStatus::Resolved as u8, 3);
}

#[test]
fn test_dispute_status_none_is_initial() {
    let initial = DisputeStatus::None;
    assert_ne!(initial, DisputeStatus::Disputed);
    assert_ne!(initial, DisputeStatus::UnderReview);
    assert_ne!(initial, DisputeStatus::Resolved);
}

#[test]
fn test_dispute_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ] {
        assert_roundtrip!(&env, status, DisputeStatus);
    }
}

// ============================================================================
// InvoiceCategory
// ============================================================================

#[test]
fn test_invoice_category_all_variants_distinct() {
    let all = [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_invoice_category_clone() {
    for cat in [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ] {
        assert_eq!(cat.clone(), cat);
    }
}

#[test]
fn test_invoice_category_discriminants() {
    assert_eq!(InvoiceCategory::Services as u8, 0);
    assert_eq!(InvoiceCategory::Products as u8, 1);
    assert_eq!(InvoiceCategory::Consulting as u8, 2);
    assert_eq!(InvoiceCategory::Manufacturing as u8, 3);
    assert_eq!(InvoiceCategory::Technology as u8, 4);
    assert_eq!(InvoiceCategory::Healthcare as u8, 5);
    assert_eq!(InvoiceCategory::Other as u8, 6);
}

#[test]
fn test_invoice_category_serialization_roundtrip() {
    let env = Env::default();
    for cat in [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ] {
        assert_roundtrip!(&env, cat, InvoiceCategory);
    }
}

// ============================================================================
// LineItemRecord
// ============================================================================

#[test]
fn test_line_item_record_fields() {
    let env = Env::default();
    let desc = String::from_str(&env, "Consulting services");
    let rec = LineItemRecord(desc.clone(), 2, 500, 1_000);
    assert_eq!(rec.0, desc);
    assert_eq!(rec.1, 2); // quantity
    assert_eq!(rec.2, 500); // unit price
    assert_eq!(rec.3, 1_000); // total
}

#[test]
fn test_line_item_record_clone_equality() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, "Item"), 1, 100, 100);
    assert_eq!(rec.clone(), rec);
}

#[test]
fn test_line_item_record_inequality() {
    let env = Env::default();
    let r1 = LineItemRecord(String::from_str(&env, "Item A"), 1, 100, 100);
    let r2 = LineItemRecord(String::from_str(&env, "Item B"), 1, 100, 100);
    let r3 = LineItemRecord(String::from_str(&env, "Item A"), 3, 100, 300);
    assert_ne!(r1, r2);
    assert_ne!(r1, r3);
}

#[test]
fn test_line_item_record_zero_values() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, ""), 0, 0, 0);
    assert_eq!(rec.1, 0);
    assert_eq!(rec.2, 0);
    assert_eq!(rec.3, 0);
}

#[test]
fn test_line_item_record_max_values() {
    let env = Env::default();
    let rec = LineItemRecord(
        String::from_str(&env, "Max item"),
        i128::MAX,
        i128::MAX,
        i128::MAX,
    );
    assert_eq!(rec.1, i128::MAX);
    assert_eq!(rec.2, i128::MAX);
    assert_eq!(rec.3, i128::MAX);
}

#[test]
fn test_line_item_record_serialization_roundtrip() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, "Software dev"), 5, 200, 1_000);
    assert_roundtrip!(&env, rec, LineItemRecord);
}

// ============================================================================
// InvoiceMetadata
// ============================================================================

#[test]
fn test_invoice_metadata_fields() {
    let env = Env::default();
    let name = String::from_str(&env, "ABC Corp");
    let addr = String::from_str(&env, "123 Main St");
    let tax = String::from_str(&env, "TAX-99");
    let notes = String::from_str(&env, "Net 30");
    let items: Vec<LineItemRecord> = Vec::new(&env);

    let m = InvoiceMetadata {
        customer_name: name.clone(),
        customer_address: addr.clone(),
        tax_id: tax.clone(),
        line_items: items.clone(),
        notes: notes.clone(),
    };
    assert_eq!(m.customer_name, name);
    assert_eq!(m.customer_address, addr);
    assert_eq!(m.tax_id, tax);
    assert_eq!(m.line_items, items);
    assert_eq!(m.notes, notes);
}

#[test]
fn test_invoice_metadata_with_line_items() {
    let env = Env::default();
    let mut items: Vec<LineItemRecord> = Vec::new(&env);
    items.push_back(LineItemRecord(
        String::from_str(&env, "Item 1"),
        1,
        100,
        100,
    ));
    items.push_back(LineItemRecord(String::from_str(&env, "Item 2"), 3, 50, 150));

    let m = InvoiceMetadata {
        customer_name: String::from_str(&env, "XYZ Ltd"),
        customer_address: String::from_str(&env, "456 Park Ave"),
        tax_id: String::from_str(&env, "TX-01"),
        line_items: items,
        notes: String::from_str(&env, "Urgent"),
    };
    assert_eq!(m.line_items.len(), 2);
    assert_eq!(m.line_items.get(0).unwrap().3, 100);
    assert_eq!(m.line_items.get(1).unwrap().3, 150);
}

#[test]
fn test_invoice_metadata_empty_fields() {
    let env = Env::default();
    let m = InvoiceMetadata {
        customer_name: String::from_str(&env, ""),
        customer_address: String::from_str(&env, ""),
        tax_id: String::from_str(&env, ""),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    assert_eq!(m.line_items.len(), 0);
}

#[test]
fn test_invoice_metadata_clone_equality() {
    let env = Env::default();
    let m = make_metadata(&env);
    assert_eq!(m.clone(), m);
}

#[test]
fn test_invoice_metadata_inequality() {
    let env = Env::default();
    let m1 = InvoiceMetadata {
        customer_name: String::from_str(&env, "Company A"),
        customer_address: String::from_str(&env, "Addr A"),
        tax_id: String::from_str(&env, "T1"),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    let m2 = InvoiceMetadata {
        customer_name: String::from_str(&env, "Company B"),
        customer_address: String::from_str(&env, "Addr B"),
        tax_id: String::from_str(&env, "T2"),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    assert_ne!(m1, m2);
}

#[test]
fn test_invoice_metadata_serialization_roundtrip() {
    let env = Env::default();
    let m = make_metadata(&env);
    assert_roundtrip!(&env, m, InvoiceMetadata);
}

// ============================================================================
// PaymentRecord
// ============================================================================

#[test]
fn test_payment_record_fields() {
    let env = Env::default();
    let tx_id = String::from_str(&env, "TX-12345");
    let rec = PaymentRecord {
        amount: 5_000,
        timestamp: 1_700_000_000,
        transaction_id: tx_id.clone(),
    };
    assert_eq!(rec.amount, 5_000);
    assert_eq!(rec.timestamp, 1_700_000_000);
    assert_eq!(rec.transaction_id, tx_id);
}

#[test]
fn test_payment_record_zero_amount() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 0,
        timestamp: 0,
        transaction_id: String::from_str(&env, "TX-ZERO"),
    };
    assert_eq!(rec.amount, 0);
    assert_eq!(rec.timestamp, 0);
}

#[test]
fn test_payment_record_clone_equality() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 1_000,
        timestamp: 9_999,
        transaction_id: String::from_str(&env, "TX-A"),
    };
    assert_eq!(rec.clone(), rec);
}

#[test]
fn test_payment_record_inequality() {
    let env = Env::default();
    let r1 = PaymentRecord {
        amount: 1_000,
        timestamp: 100,
        transaction_id: String::from_str(&env, "TX-1"),
    };
    let r2 = PaymentRecord {
        amount: 2_000,
        timestamp: 200,
        transaction_id: String::from_str(&env, "TX-2"),
    };
    assert_ne!(r1, r2);
}

#[test]
fn test_payment_record_max_amount() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: i128::MAX,
        timestamp: u64::MAX,
        transaction_id: String::from_str(&env, "TX-MAX"),
    };
    assert_eq!(rec.amount, i128::MAX);
    assert_eq!(rec.timestamp, u64::MAX);
}

#[test]
fn test_payment_record_serialization_roundtrip() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 7_500,
        timestamp: 1_600_000_000,
        transaction_id: String::from_str(&env, "TX-SER"),
    };
    assert_roundtrip!(&env, rec, PaymentRecord);
}

// ============================================================================
// Dispute
// ============================================================================

#[test]
fn test_dispute_unresolved_state() {
    let env = Env::default();
    let d = Dispute {
        created_by: Address::generate(&env),
        created_at: 1_000_000,
        reason: String::from_str(&env, "Late delivery"),
        evidence: String::from_str(&env, "Contract clause 5"),
        resolution: String::from_str(&env, ""),
        resolved_by: Address::generate(&env),
        resolved_at: 0,
    };
    assert_eq!(d.resolved_at, 0);
    assert_eq!(d.resolution, String::from_str(&env, ""));
}

#[test]
fn test_dispute_resolved_state() {
    let env = Env::default();
    let resolver = Address::generate(&env);
    let d = Dispute {
        created_by: Address::generate(&env),
        created_at: 1_000_000,
        reason: String::from_str(&env, "Non-payment"),
        evidence: String::from_str(&env, "Invoice copy"),
        resolution: String::from_str(&env, "Payment transferred"),
        resolved_by: resolver.clone(),
        resolved_at: 1_100_000,
    };
    assert_eq!(d.resolved_by, resolver);
    assert!(d.resolved_at > 0);
    assert_ne!(d.resolution, String::from_str(&env, ""));
}

#[test]
fn test_dispute_all_fields() {
    let env = Env::default();
    let creator = Address::generate(&env);
    let resolver = Address::generate(&env);
    let reason = String::from_str(&env, "Wrong amount billed");
    let evidence = String::from_str(&env, "Bank statement attached");
    let resolution = String::from_str(&env, "Partial refund issued");

    let d = Dispute {
        created_by: creator.clone(),
        created_at: 1_234_567,
        reason: reason.clone(),
        evidence: evidence.clone(),
        resolution: resolution.clone(),
        resolved_by: resolver.clone(),
        resolved_at: 1_234_999,
    };
    assert_eq!(d.created_by, creator);
    assert_eq!(d.created_at, 1_234_567);
    assert_eq!(d.reason, reason);
    assert_eq!(d.evidence, evidence);
    assert_eq!(d.resolution, resolution);
    assert_eq!(d.resolved_by, resolver);
    assert_eq!(d.resolved_at, 1_234_999);
}

#[test]
fn test_dispute_clone_equality() {
    let env = Env::default();
    let d = make_dispute(&env);
    assert_eq!(d.clone(), d);
}

#[test]
fn test_dispute_inequality() {
    let env = Env::default();
    let d1 = Dispute {
        created_by: Address::generate(&env),
        created_at: 100,
        reason: String::from_str(&env, "Reason A"),
        evidence: String::from_str(&env, "Proof A"),
        resolution: String::from_str(&env, ""),
        resolved_by: Address::generate(&env),
        resolved_at: 0,
    };
    let d2 = Dispute {
        created_by: Address::generate(&env),
        created_at: 200,
        reason: String::from_str(&env, "Reason B"),
        evidence: String::from_str(&env, "Proof B"),
        resolution: String::from_str(&env, ""),
        resolved_by: Address::generate(&env),
        resolved_at: 0,
    };
    assert_ne!(d1, d2);
}

#[test]
fn test_dispute_serialization_roundtrip() {
    let env = Env::default();
    let d = Dispute {
        created_by: Address::generate(&env),
        created_at: 999_999,
        reason: String::from_str(&env, "Wrong amount"),
        evidence: String::from_str(&env, "Bank statement"),
        resolution: String::from_str(&env, ""),
        resolved_by: Address::generate(&env),
        resolved_at: 0,
    };
    assert_roundtrip!(&env, d, Dispute);
}

// ============================================================================
// InvoiceRating
// ============================================================================

#[test]
fn test_invoice_rating_fields() {
    let env = Env::default();
    let rater = Address::generate(&env);
    let feedback = String::from_str(&env, "Excellent partnership");

    let r = InvoiceRating {
        rating: 5,
        feedback: feedback.clone(),
        rated_by: rater.clone(),
        rated_at: 1_234_567,
    };
    assert_eq!(r.rating, 5);
    assert_eq!(r.feedback, feedback);
    assert_eq!(r.rated_by, rater);
    assert_eq!(r.rated_at, 1_234_567);
}

#[test]
fn test_invoice_rating_minimum_score() {
    let env = Env::default();
    let r = InvoiceRating {
        rating: 1,
        feedback: String::from_str(&env, "Poor service"),
        rated_by: Address::generate(&env),
        rated_at: 100,
    };
    assert_eq!(r.rating, 1);
}

#[test]
fn test_invoice_rating_maximum_score() {
    let env = Env::default();
    let r = InvoiceRating {
        rating: 5,
        feedback: String::from_str(&env, "Perfect"),
        rated_by: Address::generate(&env),
        rated_at: 999,
    };
    assert_eq!(r.rating, 5);
}

#[test]
fn test_invoice_rating_clone_equality() {
    let env = Env::default();
    let r = InvoiceRating {
        rating: 4,
        feedback: String::from_str(&env, "Good"),
        rated_by: Address::generate(&env),
        rated_at: 888,
    };
    assert_eq!(r.clone(), r);
}

#[test]
fn test_invoice_rating_inequality() {
    let env = Env::default();
    let addr = Address::generate(&env);
    let r1 = InvoiceRating {
        rating: 5,
        feedback: String::from_str(&env, "Great"),
        rated_by: addr.clone(),
        rated_at: 100,
    };
    let r2 = InvoiceRating {
        rating: 3,
        feedback: String::from_str(&env, "Okay"),
        rated_by: addr,
        rated_at: 200,
    };
    assert_ne!(r1, r2);
}

#[test]
fn test_invoice_rating_serialization_roundtrip() {
    let env = Env::default();
    let r = InvoiceRating {
        rating: 4,
        feedback: String::from_str(&env, "Very good"),
        rated_by: Address::generate(&env),
        rated_at: 1_500_000,
    };
    assert_roundtrip!(&env, r, InvoiceRating);
}

// ============================================================================
// Invoice
// ============================================================================

#[test]
fn test_invoice_fields() {
    let env = Env::default();
    let id = BytesN::from_array(&env, &[1u8; 32]);
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let desc = String::from_str(&env, "Professional services");
    let tags: Vec<String> = Vec::new(&env);
    let metadata = make_metadata(&env);
    let dispute = make_dispute(&env);
    let payments: Vec<PaymentRecord> = Vec::new(&env);
    let ratings: Vec<InvoiceRating> = Vec::new(&env);

    let inv = Invoice {
        id: id.clone(),
        business: business.clone(),
        amount: 10_000,
        currency: currency.clone(),
        due_date: 1_800_000_000,
        status: InvoiceStatus::Pending,
        description: desc.clone(),
        category: InvoiceCategory::Consulting,
        tags: tags.clone(),
        metadata: metadata.clone(),
        dispute: dispute.clone(),
        payments: payments.clone(),
        ratings: ratings.clone(),
        created_at: 1_700_000_000,
        updated_at: 1_700_000_000,
    };

    assert_eq!(inv.id, id);
    assert_eq!(inv.business, business);
    assert_eq!(inv.amount, 10_000);
    assert_eq!(inv.currency, currency);
    assert_eq!(inv.due_date, 1_800_000_000);
    assert_eq!(inv.status, InvoiceStatus::Pending);
    assert_eq!(inv.description, desc);
    assert_eq!(inv.category, InvoiceCategory::Consulting);
    assert_eq!(inv.tags, tags);
    assert_eq!(inv.metadata, metadata);
    assert_eq!(inv.dispute, dispute);
    assert_eq!(inv.payments, payments);
    assert_eq!(inv.ratings, ratings);
    assert_eq!(inv.created_at, 1_700_000_000);
    assert_eq!(inv.updated_at, 1_700_000_000);
}

#[test]
fn test_invoice_clone_equality() {
    let env = Env::default();
    let inv = make_invoice(&env);
    assert_eq!(inv.clone(), inv);
}

#[test]
fn test_invoice_inequality_amount() {
    let env = Env::default();
    let inv1 = make_invoice(&env);
    let mut inv2 = make_invoice(&env);
    inv2.amount = 99_999;
    assert_ne!(inv1, inv2);
}

#[test]
fn test_invoice_inequality_status() {
    let env = Env::default();
    let inv1 = make_invoice(&env);
    let mut inv2 = make_invoice(&env);
    inv2.status = InvoiceStatus::Funded;
    assert_ne!(inv1, inv2);
}

#[test]
fn test_invoice_all_statuses_assignable() {
    let env = Env::default();
    for status in [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ] {
        let mut inv = make_invoice(&env);
        inv.status = status.clone();
        assert_eq!(inv.status, status);
    }
}

#[test]
fn test_invoice_all_categories_assignable() {
    let env = Env::default();
    for cat in [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ] {
        let mut inv = make_invoice(&env);
        inv.category = cat.clone();
        assert_eq!(inv.category, cat);
    }
}

#[test]
fn test_invoice_with_multiple_payments() {
    let env = Env::default();
    let mut inv = make_invoice(&env);
    let mut payments: Vec<PaymentRecord> = Vec::new(&env);
    payments.push_back(PaymentRecord {
        amount: 3_000,
        timestamp: 1_701_000_000,
        transaction_id: String::from_str(&env, "TX-001"),
    });
    payments.push_back(PaymentRecord {
        amount: 7_000,
        timestamp: 1_702_000_000,
        transaction_id: String::from_str(&env, "TX-002"),
    });
    inv.payments = payments;
    assert_eq!(inv.payments.len(), 2);
    assert_eq!(inv.payments.get(0).unwrap().amount, 3_000);
    assert_eq!(inv.payments.get(1).unwrap().amount, 7_000);
}

#[test]
fn test_invoice_with_multiple_ratings() {
    let env = Env::default();
    let mut inv = make_invoice(&env);
    let mut ratings: Vec<InvoiceRating> = Vec::new(&env);
    ratings.push_back(InvoiceRating {
        rating: 5,
        feedback: String::from_str(&env, "Excellent"),
        rated_by: Address::generate(&env),
        rated_at: 1_703_000_000,
    });
    ratings.push_back(InvoiceRating {
        rating: 4,
        feedback: String::from_str(&env, "Very good"),
        rated_by: Address::generate(&env),
        rated_at: 1_704_000_000,
    });
    inv.ratings = ratings;
    assert_eq!(inv.ratings.len(), 2);
    assert_eq!(inv.ratings.get(0).unwrap().rating, 5);
    assert_eq!(inv.ratings.get(1).unwrap().rating, 4);
}

#[test]
fn test_invoice_with_tags() {
    let env = Env::default();
    let mut inv = make_invoice(&env);
    let mut tags: Vec<String> = Vec::new(&env);
    tags.push_back(String::from_str(&env, "urgent"));
    tags.push_back(String::from_str(&env, "verified"));
    tags.push_back(String::from_str(&env, "healthcare"));
    inv.tags = tags;
    assert_eq!(inv.tags.len(), 3);
}

#[test]
fn test_invoice_serialization_roundtrip() {
    let env = Env::default();
    let inv = make_invoice(&env);
    assert_roundtrip!(&env, inv, Invoice);
}

// ============================================================================
// Bid
// ============================================================================

#[test]
fn test_bid_fields() {
    let env = Env::default();
    let bid_id = BytesN::from_array(&env, &[2u8; 32]);
    let invoice_id = BytesN::from_array(&env, &[1u8; 32]);
    let investor = Address::generate(&env);
    let expiry = 1_700_000_000u64 + 7 * 24 * 60 * 60;

    let bid = Bid {
        bid_id: bid_id.clone(),
        invoice_id: invoice_id.clone(),
        investor: investor.clone(),
        bid_amount: 9_000,
        expected_return: 9_500,
        timestamp: 1_700_000_000,
        status: BidStatus::Placed,
        expiration_timestamp: expiry,
    };
    assert_eq!(bid.bid_id, bid_id);
    assert_eq!(bid.invoice_id, invoice_id);
    assert_eq!(bid.investor, investor);
    assert_eq!(bid.bid_amount, 9_000);
    assert_eq!(bid.expected_return, 9_500);
    assert_eq!(bid.timestamp, 1_700_000_000);
    assert_eq!(bid.status, BidStatus::Placed);
    assert_eq!(bid.expiration_timestamp, expiry);
}

#[test]
fn test_bid_expiration_after_timestamp() {
    let env = Env::default();
    let bid = make_bid(&env);
    assert!(bid.expiration_timestamp > bid.timestamp);
}

#[test]
fn test_bid_clone_equality() {
    let env = Env::default();
    let bid = make_bid(&env);
    assert_eq!(bid.clone(), bid);
}

#[test]
fn test_bid_inequality() {
    let env = Env::default();
    let b1 = make_bid(&env);
    let mut b2 = make_bid(&env);
    b2.bid_amount = 8_000;
    assert_ne!(b1, b2);
}

#[test]
fn test_bid_all_statuses_assignable() {
    let env = Env::default();
    for status in [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ] {
        let mut bid = make_bid(&env);
        bid.status = status.clone();
        assert_eq!(bid.status, status);
    }
}

#[test]
fn test_bid_serialization_roundtrip() {
    let env = Env::default();
    let bid = make_bid(&env);
    assert_roundtrip!(&env, bid, Bid);
}

// ============================================================================
// InsuranceCoverage
// ============================================================================

#[test]
fn test_insurance_coverage_active() {
    let env = Env::default();
    let cov = make_coverage(&env);
    assert!(cov.active);
    assert_eq!(cov.coverage_percentage, 80);
    assert_eq!(cov.coverage_amount, 8_000);
    assert_eq!(cov.premium_amount, 160);
}

#[test]
fn test_insurance_coverage_inactive() {
    let env = Env::default();
    let cov = InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 5_000,
        premium_amount: 100,
        coverage_percentage: 50,
        active: false,
    };
    assert!(!cov.active);
}

#[test]
fn test_insurance_coverage_full_coverage() {
    let env = Env::default();
    let cov = InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 10_000,
        premium_amount: 200,
        coverage_percentage: 100,
        active: true,
    };
    assert_eq!(cov.coverage_percentage, 100);
}

#[test]
fn test_insurance_coverage_zero_premium() {
    let env = Env::default();
    let cov = InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 0,
        premium_amount: 0,
        coverage_percentage: 0,
        active: false,
    };
    assert_eq!(cov.premium_amount, 0);
    assert_eq!(cov.coverage_amount, 0);
}

#[test]
fn test_insurance_coverage_clone_equality() {
    let env = Env::default();
    let cov = make_coverage(&env);
    assert_eq!(cov.clone(), cov);
}

#[test]
fn test_insurance_coverage_inequality() {
    let env = Env::default();
    let c1 = InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 8_000,
        premium_amount: 80,
        coverage_percentage: 80,
        active: true,
    };
    let c2 = InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 5_000,
        premium_amount: 50,
        coverage_percentage: 50,
        active: false,
    };
    assert_ne!(c1, c2);
}

#[test]
fn test_insurance_coverage_serialization_roundtrip() {
    let env = Env::default();
    let cov = make_coverage(&env);
    assert_roundtrip!(&env, cov, InsuranceCoverage);
}

// ============================================================================
// Investment
// ============================================================================

#[test]
fn test_investment_fields() {
    let env = Env::default();
    let inv_id = BytesN::from_array(&env, &[3u8; 32]);
    let inv_oi = BytesN::from_array(&env, &[1u8; 32]);
    let investor = Address::generate(&env);

    let inv = Investment {
        investment_id: inv_id.clone(),
        invoice_id: inv_oi.clone(),
        investor: investor.clone(),
        amount: 9_000,
        funded_at: 1_700_000_000,
        status: InvestmentStatus::Active,
        insurance: Vec::new(&env),
    };
    assert_eq!(inv.investment_id, inv_id);
    assert_eq!(inv.invoice_id, inv_oi);
    assert_eq!(inv.investor, investor);
    assert_eq!(inv.amount, 9_000);
    assert_eq!(inv.funded_at, 1_700_000_000);
    assert_eq!(inv.status, InvestmentStatus::Active);
    assert_eq!(inv.insurance.len(), 0);
}

#[test]
fn test_investment_with_insurance() {
    let env = Env::default();
    let mut inv = make_investment(&env);
    let mut insurance: Vec<InsuranceCoverage> = Vec::new(&env);
    insurance.push_back(make_coverage(&env));
    insurance.push_back(InsuranceCoverage {
        provider: Address::generate(&env),
        coverage_amount: 2_000,
        premium_amount: 40,
        coverage_percentage: 20,
        active: true,
    });
    inv.insurance = insurance;
    assert_eq!(inv.insurance.len(), 2);
    assert_eq!(inv.insurance.get(0).unwrap().coverage_percentage, 80);
    assert_eq!(inv.insurance.get(1).unwrap().coverage_percentage, 20);
}

#[test]
fn test_investment_all_statuses_assignable() {
    let env = Env::default();
    for status in [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ] {
        let mut inv = make_investment(&env);
        inv.status = status.clone();
        assert_eq!(inv.status, status);
    }
}

#[test]
fn test_investment_clone_equality() {
    let env = Env::default();
    let inv = make_investment(&env);
    assert_eq!(inv.clone(), inv);
}

#[test]
fn test_investment_inequality() {
    let env = Env::default();
    let i1 = make_investment(&env);
    let mut i2 = make_investment(&env);
    i2.amount = 5_000;
    assert_ne!(i1, i2);
}

#[test]
fn test_investment_serialization_roundtrip() {
    let env = Env::default();
    let inv = make_investment(&env);
    assert_roundtrip!(&env, inv, Investment);
}

// ============================================================================
// PlatformFee
// ============================================================================

#[test]
fn test_platform_fee_fields() {
    let env = Env::default();
    let recipient = Address::generate(&env);
    let desc = String::from_str(&env, "Settlement fee");
    let fee = PlatformFee {
        fee_bps: 200,
        recipient: recipient.clone(),
        description: desc.clone(),
    };
    assert_eq!(fee.fee_bps, 200);
    assert_eq!(fee.recipient, recipient);
    assert_eq!(fee.description, desc);
}

#[test]
fn test_platform_fee_zero_bps() {
    let env = Env::default();
    let fee = make_fee(&env, 0, "Free tier");
    assert_eq!(fee.fee_bps, 0);
}

#[test]
fn test_platform_fee_max_bps() {
    let env = Env::default();
    let fee = make_fee(&env, 10_000, "Max fee");
    assert_eq!(fee.fee_bps, 10_000);
}

#[test]
fn test_platform_fee_typical_values() {
    let env = Env::default();
    assert_eq!(make_fee(&env, 50, "Verification").fee_bps, 50);
    assert_eq!(make_fee(&env, 200, "Settlement").fee_bps, 200);
    assert_eq!(make_fee(&env, 10, "Bid").fee_bps, 10);
}

#[test]
fn test_platform_fee_clone_equality() {
    let env = Env::default();
    let fee = make_fee(&env, 50, "Verification fee");
    assert_eq!(fee.clone(), fee);
}

#[test]
fn test_platform_fee_inequality() {
    let env = Env::default();
    let f1 = make_fee(&env, 50, "Fee A");
    let f2 = make_fee(&env, 100, "Fee B");
    assert_ne!(f1, f2);
}

#[test]
fn test_platform_fee_serialization_roundtrip() {
    let env = Env::default();
    let fee = make_fee(&env, 75, "Platform fee");
    assert_roundtrip!(&env, fee, PlatformFee);
}

// ============================================================================
// PlatformFeeConfig
// ============================================================================

#[test]
fn test_platform_fee_config_fields() {
    let env = Env::default();
    let cfg = make_fee_config(&env);
    assert_eq!(cfg.verification_fee.fee_bps, 25);
    assert_eq!(cfg.settlement_fee.fee_bps, 50);
    assert_eq!(cfg.bid_fee.fee_bps, 10);
    assert_eq!(cfg.investment_fee.fee_bps, 20);
}

#[test]
fn test_platform_fee_config_all_zero_fees() {
    let env = Env::default();
    let recipient = Address::generate(&env);
    let zero = |label: &str| PlatformFee {
        fee_bps: 0,
        recipient: recipient.clone(),
        description: String::from_str(&env, label),
    };
    let cfg = PlatformFeeConfig {
        verification_fee: zero("v"),
        settlement_fee: zero("s"),
        bid_fee: zero("b"),
        investment_fee: zero("i"),
    };
    assert_eq!(cfg.verification_fee.fee_bps, 0);
    assert_eq!(cfg.settlement_fee.fee_bps, 0);
    assert_eq!(cfg.bid_fee.fee_bps, 0);
    assert_eq!(cfg.investment_fee.fee_bps, 0);
}

#[test]
fn test_platform_fee_config_clone_equality() {
    let env = Env::default();
    let cfg = make_fee_config(&env);
    assert_eq!(cfg.clone(), cfg);
}

#[test]
fn test_platform_fee_config_inequality() {
    let env = Env::default();
    let c1 = make_fee_config(&env);
    let mut c2 = make_fee_config(&env);
    c2.settlement_fee.fee_bps = 999;
    assert_ne!(c1, c2);
}

#[test]
fn test_platform_fee_config_independent_recipients() {
    let env = Env::default();
    let r1 = Address::generate(&env);
    let r2 = Address::generate(&env);
    let cfg = PlatformFeeConfig {
        verification_fee: PlatformFee {
            fee_bps: 25,
            recipient: r1.clone(),
            description: String::from_str(&env, "Verification"),
        },
        settlement_fee: PlatformFee {
            fee_bps: 50,
            recipient: r2.clone(),
            description: String::from_str(&env, "Settlement"),
        },
        bid_fee: PlatformFee {
            fee_bps: 10,
            recipient: r1.clone(),
            description: String::from_str(&env, "Bid"),
        },
        investment_fee: PlatformFee {
            fee_bps: 20,
            recipient: r2.clone(),
            description: String::from_str(&env, "Investment"),
        },
    };
    assert_ne!(cfg.verification_fee.recipient, cfg.settlement_fee.recipient);
    assert_eq!(cfg.verification_fee.recipient, cfg.bid_fee.recipient);
    assert_eq!(cfg.settlement_fee.recipient, cfg.investment_fee.recipient);
}

#[test]
fn test_platform_fee_config_serialization_roundtrip() {
    let env = Env::default();
    let cfg = make_fee_config(&env);
    assert_roundtrip!(&env, cfg, PlatformFeeConfig);
}
