//! Comprehensive tests for all types defined in the `types` module.
//!
//! Covers every type in `types.rs`:
//! - **Enums**: `InvoiceStatus`, `BidStatus`, `InvestmentStatus`, `DisputeStatus`,
//!   `InvoiceCategory`
//! - **Structs**: `LineItemRecord`, `InvoiceMetadata`, `PaymentRecord`, `Dispute`,
//!   `InvoiceRating`, `Invoice`, `Bid`, `InsuranceCoverage`, `Investment`,
//!   `PlatformFee`, `PlatformFeeConfig`
//!
//! Each type is tested for:
//! - All variant / field construction and field-level assertions
//! - `Clone` correctness
//! - `PartialEq` / `Eq` (equality and inequality)
//! - Soroban serialization round-trip via `IntoVal` / `TryFromVal`
//!   (exercises the XDR encoding generated by `#[contracttype]`)
//! - Edge cases: zero values, maximum values, empty collections, large collections

use soroban_sdk::{
    testutils::Address as _, Address, BytesN, Env, IntoVal, String, TryFromVal, Val, Vec,
};

use crate::types::{
    Bid, BidStatus, Dispute, DisputeStatus, InsuranceCoverage, Investment, InvestmentStatus,
    Invoice, InvoiceCategory, InvoiceMetadata, InvoiceRating, InvoiceStatus, LineItemRecord,
    PaymentRecord, PlatformFee, PlatformFeeConfig,
};

// ============================================================================
// Shared helpers
// ============================================================================

/// Build a minimal, valid `Dispute` for use inside other structs.
fn make_dispute(env: &Env) -> Dispute {
    Dispute {
        created_by: Address::generate(env),
        created_at: 0,
        reason: String::from_str(env, ""),
        evidence: String::from_str(env, ""),
        resolution: String::from_str(env, ""),
        resolved_by: Address::generate(env),
        resolved_at: 0,
    }
}

/// Build a minimal, valid `InvoiceMetadata`.
fn make_metadata(env: &Env) -> InvoiceMetadata {
    InvoiceMetadata {
        customer_name: String::from_str(env, "Test Corp"),
        customer_address: String::from_str(env, "1 Test St"),
        tax_id: String::from_str(env, "TAX-001"),
        line_items: Vec::new(env),
        notes: String::from_str(env, ""),
    }
}

/// Build a minimal, valid `Invoice`.
fn make_invoice(env: &Env) -> Invoice {
    Invoice {
        id: BytesN::from_array(env, &[1u8; 32]),
        business: Address::generate(env),
        amount: 10_000,
        currency: Address::generate(env),
        due_date: 1_800_000_000,
        status: InvoiceStatus::Pending,
        description: String::from_str(env, "Test invoice"),
        category: InvoiceCategory::Services,
        tags: Vec::new(env),
        metadata: make_metadata(env),
        dispute: make_dispute(env),
        payments: Vec::new(env),
        ratings: Vec::new(env),
        created_at: 1_700_000_000,
        updated_at: 1_700_000_000,
    }
}

/// Build a minimal, valid `Bid`.
fn make_bid(env: &Env) -> Bid {
    Bid {
        bid_id: BytesN::from_array(env, &[2u8; 32]),
        invoice_id: BytesN::from_array(env, &[1u8; 32]),
        investor: Address::generate(env),
        bid_amount: 9_000,
        expected_return: 9_500,
        timestamp: 1_700_000_000,
        status: BidStatus::Placed,
        expiration_timestamp: 1_700_000_000 + 7 * 24 * 60 * 60,
    }
}

/// Build a minimal, valid `InsuranceCoverage`.
fn make_coverage(env: &Env) -> InsuranceCoverage {
    InsuranceCoverage {
        provider: Address::generate(env),
        coverage_amount: 8_000,
        premium_amount: 160,
        coverage_percentage: 80,
        active: true,
    }
}

/// Build a minimal, valid `Investment`.
fn make_investment(env: &Env) -> Investment {
    Investment {
        investment_id: BytesN::from_array(env, &[3u8; 32]),
        invoice_id: BytesN::from_array(env, &[1u8; 32]),
        investor: Address::generate(env),
        amount: 9_000,
        funded_at: 1_700_000_000,
        status: InvestmentStatus::Active,
        insurance: Vec::new(env),
    }
}

/// Build a `PlatformFee` with the given basis-points value.
fn make_fee(env: &Env, bps: u32, label: &str) -> PlatformFee {
    PlatformFee {
        fee_bps: bps,
        recipient: Address::generate(env),
        description: String::from_str(env, label),
    }
}

/// Build a full `PlatformFeeConfig`.
fn make_fee_config(env: &Env) -> PlatformFeeConfig {
    PlatformFeeConfig {
        verification_fee: make_fee(env, 25, "Verification"),
        settlement_fee: make_fee(env, 50, "Settlement"),
        bid_fee: make_fee(env, 10, "Bid"),
        investment_fee: make_fee(env, 20, "Investment"),
    }
}

/// Helper: assert a `#[contracttype]` value survives an XDR round-trip.
macro_rules! assert_roundtrip {
    ($env:expr, $val:expr, $T:ty) => {{
        let val: Val = ($val).clone().into_val($env);
        let recovered = <$T>::try_from_val($env, &val).unwrap();
        assert_eq!(($val).clone(), recovered);
    }};
}

// ============================================================================
// InvoiceStatus
// ============================================================================

#[test]
fn test_invoice_status_all_variants_distinct() {
    let all = [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b, "variant {i} should equal itself");
            } else {
                assert_ne!(a, b, "variants {i} and {j} should differ");
            }
        }
    }
}

#[test]
fn test_invoice_status_clone() {
    for status in [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_invoice_status_discriminants() {
    assert_eq!(InvoiceStatus::Pending as u8, 0);
    assert_eq!(InvoiceStatus::Verified as u8, 1);
    assert_eq!(InvoiceStatus::Funded as u8, 2);
    assert_eq!(InvoiceStatus::Paid as u8, 3);
    assert_eq!(InvoiceStatus::Defaulted as u8, 4);
    assert_eq!(InvoiceStatus::Cancelled as u8, 5);
}

#[test]
fn test_invoice_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        InvoiceStatus::Pending,
        InvoiceStatus::Verified,
        InvoiceStatus::Funded,
        InvoiceStatus::Paid,
        InvoiceStatus::Defaulted,
        InvoiceStatus::Cancelled,
    ] {
        assert_roundtrip!(&env, status, InvoiceStatus);
    }
}

// ============================================================================
// BidStatus
// ============================================================================

#[test]
fn test_bid_status_all_variants_distinct() {
    let all = [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_bid_status_clone() {
    for status in [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_bid_status_discriminants() {
    assert_eq!(BidStatus::Placed as u8, 0);
    assert_eq!(BidStatus::Withdrawn as u8, 1);
    assert_eq!(BidStatus::Accepted as u8, 2);
    assert_eq!(BidStatus::Expired as u8, 3);
}

#[test]
fn test_bid_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        BidStatus::Placed,
        BidStatus::Withdrawn,
        BidStatus::Accepted,
        BidStatus::Expired,
    ] {
        assert_roundtrip!(&env, status, BidStatus);
    }
}

// ============================================================================
// InvestmentStatus
// ============================================================================

#[test]
fn test_investment_status_all_variants_distinct() {
    let all = [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_investment_status_clone() {
    for status in [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_investment_status_discriminants() {
    assert_eq!(InvestmentStatus::Active as u8, 0);
    assert_eq!(InvestmentStatus::Withdrawn as u8, 1);
    assert_eq!(InvestmentStatus::Completed as u8, 2);
    assert_eq!(InvestmentStatus::Defaulted as u8, 3);
}

#[test]
fn test_investment_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        InvestmentStatus::Active,
        InvestmentStatus::Withdrawn,
        InvestmentStatus::Completed,
        InvestmentStatus::Defaulted,
    ] {
        assert_roundtrip!(&env, status, InvestmentStatus);
    }
}

// ============================================================================
// DisputeStatus
// ============================================================================

#[test]
fn test_dispute_status_all_variants_distinct() {
    let all = [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_dispute_status_clone() {
    for status in [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ] {
        assert_eq!(status.clone(), status);
    }
}

#[test]
fn test_dispute_status_discriminants() {
    assert_eq!(DisputeStatus::None as u8, 0);
    assert_eq!(DisputeStatus::Disputed as u8, 1);
    assert_eq!(DisputeStatus::UnderReview as u8, 2);
    assert_eq!(DisputeStatus::Resolved as u8, 3);
}

#[test]
fn test_dispute_status_none_is_initial() {
    let initial = DisputeStatus::None;
    assert_ne!(initial, DisputeStatus::Disputed);
    assert_ne!(initial, DisputeStatus::UnderReview);
    assert_ne!(initial, DisputeStatus::Resolved);
}

#[test]
fn test_dispute_status_serialization_roundtrip() {
    let env = Env::default();
    for status in [
        DisputeStatus::None,
        DisputeStatus::Disputed,
        DisputeStatus::UnderReview,
        DisputeStatus::Resolved,
    ] {
        assert_roundtrip!(&env, status, DisputeStatus);
    }
}

// ============================================================================
// InvoiceCategory
// ============================================================================

#[test]
fn test_invoice_category_all_variants_distinct() {
    let all = [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ];
    for (i, a) in all.iter().enumerate() {
        for (j, b) in all.iter().enumerate() {
            if i == j {
                assert_eq!(a, b);
            } else {
                assert_ne!(a, b);
            }
        }
    }
}

#[test]
fn test_invoice_category_clone() {
    for cat in [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ] {
        assert_eq!(cat.clone(), cat);
    }
}

#[test]
fn test_invoice_category_discriminants() {
    assert_eq!(InvoiceCategory::Services as u8, 0);
    assert_eq!(InvoiceCategory::Products as u8, 1);
    assert_eq!(InvoiceCategory::Consulting as u8, 2);
    assert_eq!(InvoiceCategory::Manufacturing as u8, 3);
    assert_eq!(InvoiceCategory::Technology as u8, 4);
    assert_eq!(InvoiceCategory::Healthcare as u8, 5);
    assert_eq!(InvoiceCategory::Other as u8, 6);
}

#[test]
fn test_invoice_category_serialization_roundtrip() {
    let env = Env::default();
    for cat in [
        InvoiceCategory::Services,
        InvoiceCategory::Products,
        InvoiceCategory::Consulting,
        InvoiceCategory::Manufacturing,
        InvoiceCategory::Technology,
        InvoiceCategory::Healthcare,
        InvoiceCategory::Other,
    ] {
        assert_roundtrip!(&env, cat, InvoiceCategory);
    }
}

// ============================================================================
// LineItemRecord
// ============================================================================

#[test]
fn test_line_item_record_fields() {
    let env = Env::default();
    let desc = String::from_str(&env, "Consulting services");
    let rec = LineItemRecord(desc.clone(), 2, 500, 1_000);
    assert_eq!(rec.0, desc);
    assert_eq!(rec.1, 2); // quantity
    assert_eq!(rec.2, 500); // unit price
    assert_eq!(rec.3, 1_000); // total
}

#[test]
fn test_line_item_record_clone_equality() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, "Item"), 1, 100, 100);
    assert_eq!(rec.clone(), rec);
}

#[test]
fn test_line_item_record_inequality() {
    let env = Env::default();
    let r1 = LineItemRecord(String::from_str(&env, "Item A"), 1, 100, 100);
    let r2 = LineItemRecord(String::from_str(&env, "Item B"), 1, 100, 100);
    let r3 = LineItemRecord(String::from_str(&env, "Item A"), 3, 100, 300);
    assert_ne!(r1, r2);
    assert_ne!(r1, r3);
}

#[test]
fn test_line_item_record_zero_values() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, ""), 0, 0, 0);
    assert_eq!(rec.1, 0);
    assert_eq!(rec.2, 0);
    assert_eq!(rec.3, 0);
}

#[test]
fn test_line_item_record_max_values() {
    let env = Env::default();
    let rec = LineItemRecord(
        String::from_str(&env, "Max item"),
        i128::MAX,
        i128::MAX,
        i128::MAX,
    );
    assert_eq!(rec.1, i128::MAX);
    assert_eq!(rec.2, i128::MAX);
    assert_eq!(rec.3, i128::MAX);
}

#[test]
fn test_line_item_record_serialization_roundtrip() {
    let env = Env::default();
    let rec = LineItemRecord(String::from_str(&env, "Software dev"), 5, 200, 1_000);
    assert_roundtrip!(&env, rec, LineItemRecord);
}

// ============================================================================
// InvoiceMetadata
// ============================================================================

#[test]
fn test_invoice_metadata_fields() {
    let env = Env::default();
    let name = String::from_str(&env, "ABC Corp");
    let addr = String::from_str(&env, "123 Main St");
    let tax = String::from_str(&env, "TAX-99");
    let notes = String::from_str(&env, "Net 30");
    let items: Vec<LineItemRecord> = Vec::new(&env);

    let m = InvoiceMetadata {
        customer_name: name.clone(),
        customer_address: addr.clone(),
        tax_id: tax.clone(),
        line_items: items.clone(),
        notes: notes.clone(),
    };
    assert_eq!(m.customer_name, name);
    assert_eq!(m.customer_address, addr);
    assert_eq!(m.tax_id, tax);
    assert_eq!(m.line_items, items);
    assert_eq!(m.notes, notes);
}

#[test]
fn test_invoice_metadata_with_line_items() {
    let env = Env::default();
    let mut items: Vec<LineItemRecord> = Vec::new(&env);
    items.push_back(LineItemRecord(
        String::from_str(&env, "Item 1"),
        1,
        100,
        100,
    ));
    items.push_back(LineItemRecord(String::from_str(&env, "Item 2"), 3, 50, 150));

    let m = InvoiceMetadata {
        customer_name: String::from_str(&env, "XYZ Ltd"),
        customer_address: String::from_str(&env, "456 Park Ave"),
        tax_id: String::from_str(&env, "TX-01"),
        line_items: items,
        notes: String::from_str(&env, "Urgent"),
    };
    assert_eq!(m.line_items.len(), 2);
    assert_eq!(m.line_items.get(0).unwrap().3, 100);
    assert_eq!(m.line_items.get(1).unwrap().3, 150);
}

#[test]
fn test_invoice_metadata_empty_fields() {
    let env = Env::default();
    let m = InvoiceMetadata {
        customer_name: String::from_str(&env, ""),
        customer_address: String::from_str(&env, ""),
        tax_id: String::from_str(&env, ""),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    assert_eq!(m.line_items.len(), 0);
}

#[test]
fn test_invoice_metadata_clone_equality() {
    let env = Env::default();
    let m = make_metadata(&env);
    assert_eq!(m.clone(), m);
}

#[test]
fn test_invoice_metadata_inequality() {
    let env = Env::default();
    let m1 = InvoiceMetadata {
        customer_name: String::from_str(&env, "Company A"),
        customer_address: String::from_str(&env, "Addr A"),
        tax_id: String::from_str(&env, "T1"),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    let m2 = InvoiceMetadata {
        customer_name: String::from_str(&env, "Company B"),
        customer_address: String::from_str(&env, "Addr B"),
        tax_id: String::from_str(&env, "T2"),
        line_items: Vec::new(&env),
        notes: String::from_str(&env, ""),
    };
    assert_ne!(m1, m2);
}

#[test]
fn test_invoice_metadata_serialization_roundtrip() {
    let env = Env::default();
    let m = make_metadata(&env);
    assert_roundtrip!(&env, m, InvoiceMetadata);
}

// ============================================================================
// PaymentRecord
// ============================================================================

#[test]
fn test_payment_record_fields() {
    let env = Env::default();
    let tx_id = String::from_str(&env, "TX-12345");
    let rec = PaymentRecord {
        amount: 5_000,
        timestamp: 1_700_000_000,
        transaction_id: tx_id.clone(),
    };
    assert_eq!(rec.amount, 5_000);
    assert_eq!(rec.timestamp, 1_700_000_000);
    assert_eq!(rec.transaction_id, tx_id);
}

#[test]
fn test_payment_record_zero_amount() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 0,
        timestamp: 0,
        transaction_id: String::from_str(&env, "TX-ZERO"),
    };
    assert_eq!(rec.amount, 0);
    assert_eq!(rec.timestamp, 0);
}

#[test]
fn test_payment_record_clone_equality() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 1_000,
        timestamp: 9_999,
        transaction_id: String::from_str(&env, "TX-A"),
    };
    assert_eq!(rec.clone(), rec);
}

#[test]
fn test_payment_record_inequality() {
    let env = Env::default();
    let r1 = PaymentRecord {
        amount: 1_000,
        timestamp: 100,
        transaction_id: String::from_str(&env, "TX-1"),
    };
    let r2 = PaymentRecord {
        amount: 2_000,
        timestamp: 200,
        transaction_id: String::from_str(&env, "TX-2"),
    };
    assert_ne!(r1, r2);
}

#[test]
fn test_payment_record_max_amount() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: i128::MAX,
        timestamp: u64::MAX,
        transaction_id: String::from_str(&env, "TX-MAX"),
    };
    assert_eq!(rec.amount, i128::MAX);
    assert_eq!(rec.timestamp, u64::MAX);
}

#[test]
fn test_payment_record_serialization_roundtrip() {
    let env = Env::default();
    let rec = PaymentRecord {
        amount: 7_500,
        timestamp: 1_600_000_000,
        transaction_id: String::from_str(&env, "TX-SER"),
    };
    assert_roundtrip!(&env, rec, PaymentRecord);
}

// ============================================================================
// Dispute
// ============================================================================

#[test]
fn test_dispute_unresolved_state() {
    let env = Env::default();
    let d = Dispute {
        created_by: Address::generate(&env),
        created_at: 1_000_000,
        reason: String::from_str(&env, "Late delivery"),
        evidence: String::from_str(&env, "Contract clause 5"),
        resolution: String::from_str(&env, ""),
        resolved_by: Address::generate(&env),
        resolved_at: 0,
    };
    assert_eq!(d.resolved_at, 0);
    assert_eq!(d.resolution, String::from_str(&env, ""));
}

#[test]
fn test_dispute_resolved_state() {
    let env = Env::default();
    let resolver = Address::generate(&env);
    let d = Dispute {
        created_by: Address::generate(&env),
        created_at: 1_000_000,
        reason: String::from_str(&env, "Non-payment"),
        evidence: String::from_str(&env, "Invoice copy"),
        resolution: String::from_str(&env, "Payment transferred"),
        resolved_by: resolver.clone(),
        resolved_at: 1_100_000,
    };
    assert_eq!(d.resolved_by, resolver);
    assert!(d.resolved_at > 0);
    assert_ne!(d.resolution, String::from_str(&env, ""));
}

