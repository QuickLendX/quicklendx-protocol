#![cfg(test)]
extern crate alloc;

use crate::invoice::InvoiceCategory;
use crate::verification::BusinessVerificationStatus;
use crate::QuickLendXContract;
use soroban_sdk::{
    testutils::{Address as _, Ledger},
    Address, Env, String, Vec,
};

// The client is auto-generated by the Soroban SDK
type QuickLendXContractClient<'a> = crate::QuickLendXContractClient<'a>;

/// Setup function for tests
fn setup() -> (Env, QuickLendXContractClient<'static>, Address) {
    let env = Env::default();
    env.mock_all_auths();
    let contract_id = env.register(QuickLendXContract, ());
    let client = QuickLendXContractClient::new(&env, &contract_id);

    // Set up admin
    let admin = Address::generate(&env);
    client.set_admin(&admin);

    (env, client, admin)
}

/// Helper function to create test KYC data
fn create_test_kyc_data(env: &Env, business_name: &str) -> String {
    let kyc_json = alloc::format!(
        "{{\"business_name\":\"{}\",\"tax_id\":\"123456789\",\"registration_number\":\"REG123\",\"address\":\"123 Business St\",\"phone\":\"+1234567890\",\"email\":\"{}@example.com\"}}",
        business_name,
        business_name.to_lowercase()
    );
    String::from_str(env, &kyc_json)
}

// ============================================================================
// Business KYC Submission Tests
// ============================================================================

#[test]
fn test_business_can_submit_own_kyc() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Advance ledger time to ensure timestamp is not 0
    env.ledger().with_mut(|li| li.timestamp = 1000);

    // Business should be able to submit their own KYC
    client.submit_kyc_application(&business, &kyc_data);

    // Verify KYC was submitted correctly
    let verification = client.get_business_verification_status(&business);

    assert!(verification.is_some());

    let verification = verification.unwrap();
    assert_eq!(verification.business, business);
    assert_eq!(verification.kyc_data, kyc_data);
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert!(verification.verified_at.is_none());
    assert!(verification.verified_by.is_none());
    assert!(verification.rejection_reason.is_none());
    assert!(verification.submitted_at > 0);
}

#[test]
fn test_business_cannot_submit_kyc_for_another_business() {
    let (env, client, _admin) = setup();
    let business_a = Address::generate(&env);
    let business_b = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Business A submits their own KYC (should work)
    client.submit_kyc_application(&business_a, &kyc_data);

    // Verify only business A has KYC submitted
    let verification_a = client.get_business_verification_status(&business_a);
    let verification_b = client.get_business_verification_status(&business_b);

    assert!(verification_a.is_some());
    assert!(verification_b.is_none());
}

#[test]
fn test_kyc_submission_with_empty_data() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let empty_kyc_data = String::from_str(&env, "");

    // Submit KYC with empty data - should succeed at contract level
    client.submit_kyc_application(&business, &empty_kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, empty_kyc_data);
}

#[test]
fn test_kyc_already_pending_error() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Try to submit again - should fail with KYCAlreadyPending error
    let result = client.try_submit_kyc_application(&business, &kyc_data);
    assert!(result.is_err());
}

#[test]
fn test_kyc_already_verified_error() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Try to submit KYC again - should fail with KYCAlreadyVerified error
    let result = client.try_submit_kyc_application(&business, &kyc_data);
    assert!(result.is_err());
}

#[test]
fn test_kyc_resubmission_after_rejection() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Incomplete documentation");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Reject the application
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify rejection
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Rejected
    ));
    assert_eq!(verification.rejection_reason, Some(rejection_reason));

    // Business should be able to resubmit after rejection
    let new_kyc_data = create_test_kyc_data(&env, "TestBusinessUpdated");
    client.submit_kyc_application(&business, &new_kyc_data);

    // Verify resubmission was successful
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert_eq!(verification.kyc_data, new_kyc_data);
    assert!(verification.rejection_reason.is_none()); // Should be cleared on resubmission
}

// ============================================================================
// Admin Verification Tests
// ============================================================================

#[test]
fn test_only_admin_can_verify_business() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let non_admin = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Non-admin tries to verify - should fail
    let result = client.try_verify_business(&non_admin, &business);
    assert!(result.is_err());

    // Admin verifies - should succeed
    client.verify_business(&admin, &business);

    // Verify the business is now verified
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Verified
    ));
    assert!(verification.verified_at.is_some());
    assert_eq!(verification.verified_by, Some(admin));
}

#[test]
fn test_only_admin_can_reject_business() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let non_admin = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Insufficient documentation");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Non-admin tries to reject - should fail
    let result = client.try_reject_business(&non_admin, &business, &rejection_reason);
    assert!(result.is_err());

    // Admin rejects - should succeed
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify the business is now rejected
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Rejected
    ));
    assert_eq!(verification.rejection_reason, Some(rejection_reason));
}

// ============================================================================
// Business Authorization Tests
// ============================================================================

#[test]
fn test_unverified_business_cannot_upload_invoice() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400; // 1 day from now
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    // Try to upload invoice without verification - should fail
    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());
}

#[test]
fn test_verified_business_can_upload_invoice() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Upload invoice - should succeed
    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    // Verify invoice was created
    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
    assert_eq!(invoice.amount, amount);
    assert_eq!(invoice.description, description);
}

// ============================================================================
// KYC Status Query Tests
// ============================================================================

#[test]
fn test_get_business_verification_status_returns_none_for_unsubmitted() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);

    // Business that hasn't submitted KYC should return None
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_none());
}

#[test]
fn test_get_verification_lists() {
    let (env, client, admin) = setup();
    let business1 = Address::generate(&env);
    let business2 = Address::generate(&env);
    let business3 = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit KYC for all businesses
    client.submit_kyc_application(&business1, &kyc_data);
    client.submit_kyc_application(&business2, &kyc_data);
    client.submit_kyc_application(&business3, &kyc_data);

    // Verify business1, reject business2, leave business3 pending
    client.verify_business(&admin, &business1);
    client.reject_business(&admin, &business2, &rejection_reason);

    // Check lists
    let verified = client.get_verified_businesses();
    let pending = client.get_pending_businesses();
    let rejected = client.get_rejected_businesses();

    assert_eq!(verified.len(), 1);
    assert!(verified.contains(&business1));

    assert_eq!(pending.len(), 1);
    assert!(pending.contains(&business3));

    assert_eq!(rejected.len(), 1);
    assert!(rejected.contains(&business2));
}

// ============================================================================
// Integration Tests
// ============================================================================

#[test]
fn test_complete_business_kyc_to_invoice_flow() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Step 1: Business submits KYC
    client.submit_kyc_application(&business, &kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Pending
    ));

    // Step 2: Admin verifies business
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Verified
    ));

    // Step 3: Business uploads invoice
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice for verified business");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    // Step 4: Verify invoice was created correctly
    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
    assert_eq!(invoice.amount, amount);
    assert_eq!(invoice.description, description);

    // Step 5: Admin verifies invoice
    client.verify_invoice(&invoice_id);

    let invoice = client.get_invoice(&invoice_id);
    assert!(matches!(
        invoice.status,
        crate::invoice::InvoiceStatus::Verified
    ));
}

#[test]
fn test_rejected_business_resubmission_flow() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Incomplete tax documentation");

    // Step 1: Submit initial KYC
    client.submit_kyc_application(&business, &kyc_data);

    // Step 2: Admin rejects
    client.reject_business(&admin, &business, &rejection_reason);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Rejected
    ));

    // Step 3: Business cannot upload invoice while rejected
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());

    // Step 4: Business resubmits with updated KYC
    let updated_kyc_data = create_test_kyc_data(&env, "TestBusinessUpdated");
    client.submit_kyc_application(&business, &updated_kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert_eq!(verification.kyc_data, updated_kyc_data);

    // Step 5: Admin verifies updated KYC
    client.verify_business(&admin, &business);

    // Step 6: Business can now upload invoice
    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
}

// ============================================================================
// Edge Cases and Security Tests
// ============================================================================

#[test]
fn test_multiple_businesses_independent_kyc_processes() {
    let (env, client, admin) = setup();
    let business1 = Address::generate(&env);
    let business2 = Address::generate(&env);
    let kyc_data1 = create_test_kyc_data(&env, "Business1");
    let kyc_data2 = create_test_kyc_data(&env, "Business2");

    // Both businesses submit KYC independently
    client.submit_kyc_application(&business1, &kyc_data1);
    client.submit_kyc_application(&business2, &kyc_data2);

    // Verify only business1
    client.verify_business(&admin, &business1);

    // Check that business1 is verified and business2 is still pending
    let verification1 = client.get_business_verification_status(&business1);
    let verification2 = client.get_business_verification_status(&business2);

    assert!(verification1.is_some());
    assert!(matches!(
        verification1.unwrap().status,
        BusinessVerificationStatus::Verified
    ));

    assert!(verification2.is_some());
    assert!(matches!(
        verification2.unwrap().status,
        BusinessVerificationStatus::Pending
    ));
}

#[test]
fn test_kyc_data_integrity() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let original_kyc_data = create_test_kyc_data(&env, "OriginalBusiness");

    // Submit KYC
    client.submit_kyc_application(&business, &original_kyc_data);

    // Verify the data is stored correctly
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, original_kyc_data);

    // Verify business
    client.verify_business(&admin, &business);

    // Ensure data is still intact after verification
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, original_kyc_data);
}

#[test]
fn test_timestamp_accuracy() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    let submission_time = env.ledger().timestamp();

    // Submit KYC
    client.submit_kyc_application(&business, &kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    // Submitted timestamp should be at or after submission time
    assert!(verification.submitted_at >= submission_time);

    let verification_time = env.ledger().timestamp();

    // Verify business
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    // Verified timestamp should be at or after verification time
    assert!(verification.verified_at.is_some());
    assert!(verification.verified_at.unwrap() >= verification_time);
}

// ============================================================================
// Additional Edge Cases and Security Tests
// ============================================================================

// Additional Coverage Tests - Admin Authorization Edge Cases
// ============================================================================

#[test]
fn test_verify_business_without_kyc_submission_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);

    // Try to verify a business that hasn't submitted KYC - should fail
    let result = client.try_verify_business(&admin, &business);
    assert!(result.is_err());
}

#[test]
fn test_reject_business_without_kyc_submission_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Try to reject a business that hasn't submitted KYC - should fail
    let result = client.try_reject_business(&admin, &business, &rejection_reason);
    assert!(result.is_err());
}

#[test]
fn test_double_verification_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Try to verify again - should fail with InvalidKYCStatus
    let result = client.try_verify_business(&admin, &business);
    assert!(result.is_err());
}

#[test]
fn test_double_rejection_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit and reject KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    // Try to reject again - should fail with InvalidKYCStatus
    let result = client.try_reject_business(&admin, &business, &rejection_reason);
    assert!(result.is_err());
}

#[test]
fn test_verify_already_rejected_business_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit and reject KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    // Try to verify rejected business - should fail
    let result = client.try_verify_business(&admin, &business);
    assert!(result.is_err());
}

#[test]
fn test_full_rejection_resubmission_verification_cycle() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let reason = String::from_str(&env, "Missing tax ID");

    // Submit -> Reject -> Resubmit -> Verify
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &reason);

    let updated_kyc = create_test_kyc_data(&env, "TestBusinessComplete");
    client.submit_kyc_application(&business, &updated_kyc);
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let v = verification.unwrap();
    assert!(matches!(v.status, BusinessVerificationStatus::Verified));
    assert_eq!(v.kyc_data, updated_kyc);
    assert!(v.verified_at.is_some());
    assert!(v.verified_by.is_some());
    assert!(v.rejection_reason.is_none());
}

#[test]
fn test_verification_lists_consistency_after_transitions() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let reason = String::from_str(&env, "Bad docs");

    // Submit: should appear in pending
    client.submit_kyc_application(&business, &kyc_data);
    assert!(client.get_pending_businesses().contains(&business));
    assert!(!client.get_verified_businesses().contains(&business));
    assert!(!client.get_rejected_businesses().contains(&business));

    // Verify: should move from pending to verified
    client.verify_business(&admin, &business);
    assert!(!client.get_pending_businesses().contains(&business));
    assert!(client.get_verified_businesses().contains(&business));
    assert!(!client.get_rejected_businesses().contains(&business));
}

#[test]
fn test_rejection_lists_consistency() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let reason = String::from_str(&env, "Fraudulent docs");

    // Submit and reject
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &reason);

    assert!(!client.get_pending_businesses().contains(&business));
    assert!(!client.get_verified_businesses().contains(&business));
    assert!(client.get_rejected_businesses().contains(&business));
}

#[test]
fn test_large_kyc_data_submission() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);

    // Submit KYC with large data payload
    let large_data = String::from_str(
        &env,
        "{\"business_name\":\"LargeCorp\",\"tax_id\":\"999999999\",\"registration_number\":\"REG999\",\"address\":\"999 Enterprise Blvd, Suite 100, Business City, BC 99999\",\"phone\":\"+19999999999\",\"email\":\"contact@largecorp.example.com\",\"directors\":[\"Alice\",\"Bob\",\"Charlie\"],\"annual_revenue\":\"50000000\",\"employees\":\"500\",\"industry\":\"Technology\",\"founded\":\"2010\",\"website\":\"https://largecorp.example.com\"}",
    );

    client.submit_kyc_application(&business, &large_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, large_data);
}

#[test]
fn test_multiple_businesses_concurrent_kyc() {
    let (env, client, admin) = setup();

    // Submit KYC for 5 businesses
    let mut businesses = alloc::vec::Vec::new();
    for i in 0..5 {
        let business = Address::generate(&env);
        let name = alloc::format!("Business{}", i);
        let kyc_data = create_test_kyc_data(&env, &name);
        client.submit_kyc_application(&business, &kyc_data);
        businesses.push(business);
    }

    // All should be pending
    let pending = client.get_pending_businesses();
    assert_eq!(pending.len(), 5);

    // Verify first 3, reject last 2
    for business in businesses.iter().take(3) {
        client.verify_business(&admin, business);
    }
    let reason = String::from_str(&env, "Rejected");
    for business in businesses.iter().skip(3) {
        client.reject_business(&admin, business, &reason);
    }

    assert_eq!(client.get_verified_businesses().len(), 3);
    assert_eq!(client.get_rejected_businesses().len(), 2);
    assert_eq!(client.get_pending_businesses().len(), 0);
}

#[test]
fn test_reject_already_verified_business_fails() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Try to reject verified business - should fail
    let result = client.try_reject_business(&admin, &business, &rejection_reason);
    assert!(result.is_err());
}

// ============================================================================
// List Management Consistency Tests
// ============================================================================

#[test]
fn test_verified_list_updates_correctly_on_verification() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Initially no verified businesses
    let verified_before = client.get_verified_businesses();
    assert_eq!(verified_before.len(), 0);

    // Submit KYC - should be in pending list
    client.submit_kyc_application(&business, &kyc_data);
    let pending = client.get_pending_businesses();
    assert!(pending.contains(&business));

    // Verify - should move from pending to verified
    client.verify_business(&admin, &business);

    let verified_after = client.get_verified_businesses();
    let pending_after = client.get_pending_businesses();

    assert!(verified_after.contains(&business));
    assert!(!pending_after.contains(&business));
}

#[test]
fn test_rejected_list_updates_correctly_on_rejection() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit KYC - should be in pending list
    client.submit_kyc_application(&business, &kyc_data);
    let pending = client.get_pending_businesses();
    assert!(pending.contains(&business));

    // Reject - should move from pending to rejected
    client.reject_business(&admin, &business, &rejection_reason);

    let rejected_after = client.get_rejected_businesses();
    let pending_after = client.get_pending_businesses();

    assert!(rejected_after.contains(&business));
    assert!(!pending_after.contains(&business));
}

#[test]
fn test_resubmission_moves_from_rejected_to_pending() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit and reject
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify in rejected list
    let rejected = client.get_rejected_businesses();
    assert!(rejected.contains(&business));

    // Resubmit
    let new_kyc_data = create_test_kyc_data(&env, "UpdatedBusiness");
    client.submit_kyc_application(&business, &new_kyc_data);

    // Should be in pending, not rejected
    let pending_after = client.get_pending_businesses();
    assert!(pending_after.contains(&business));
}

// ============================================================================
// Pending Business Invoice Upload Tests
// ============================================================================

#[test]
fn test_pending_business_cannot_upload_invoice() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    // Submit KYC but don't verify
    client.submit_kyc_application(&business, &kyc_data);

    // Try to upload invoice while pending - should fail
    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());
}

#[test]
fn test_rejected_business_cannot_upload_invoice() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Incomplete docs");
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    // Submit and reject KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    // Try to upload invoice while rejected - should fail
    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());
}

// ============================================================================
// Large Scale Tests
// ============================================================================

#[test]
fn test_multiple_businesses_all_statuses() {
    let (env, client, admin) = setup();
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Create 5 businesses with different statuses
    let business_verified_1 = Address::generate(&env);
    let business_verified_2 = Address::generate(&env);
    let business_pending = Address::generate(&env);
    let business_rejected_1 = Address::generate(&env);
    let business_rejected_2 = Address::generate(&env);

    // Submit all KYC applications
    client.submit_kyc_application(&business_verified_1, &create_test_kyc_data(&env, "V1"));
    client.submit_kyc_application(&business_verified_2, &create_test_kyc_data(&env, "V2"));
    client.submit_kyc_application(&business_pending, &create_test_kyc_data(&env, "P1"));
    client.submit_kyc_application(&business_rejected_1, &create_test_kyc_data(&env, "R1"));
    client.submit_kyc_application(&business_rejected_2, &create_test_kyc_data(&env, "R2"));

    // Verify 2 businesses
    client.verify_business(&admin, &business_verified_1);
    client.verify_business(&admin, &business_verified_2);

    // Reject 2 businesses
    client.reject_business(&admin, &business_rejected_1, &rejection_reason);
    client.reject_business(&admin, &business_rejected_2, &rejection_reason);

    // Leave 1 pending

    // Verify counts
    let verified = client.get_verified_businesses();
    let pending = client.get_pending_businesses();
    let rejected = client.get_rejected_businesses();

    assert_eq!(verified.len(), 2);
    assert_eq!(pending.len(), 1);
    assert_eq!(rejected.len(), 2);

    // Verify correct businesses in each list
    assert!(verified.contains(&business_verified_1));
    assert!(verified.contains(&business_verified_2));
    assert!(pending.contains(&business_pending));
    assert!(rejected.contains(&business_rejected_1));
    assert!(rejected.contains(&business_rejected_2));
}

// ============================================================================
// KYC Data Validation Tests
// ============================================================================

#[test]
fn test_kyc_with_special_characters() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let special_kyc_data = String::from_str(
        &env,
        "{\"business_name\":\"Test & Co. <LLC>\",\"tax_id\":\"123-45-6789\",\"notes\":\"Special chars: @#$%^&*()\"}"
    );

    // Submit KYC with special characters - should succeed
    client.submit_kyc_application(&business, &special_kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, special_kyc_data);
}

#[test]
fn test_kyc_with_long_data() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    
    // Create a long KYC data string
    let long_data = String::from_str(
        &env,
        "{\"business_name\":\"Very Long Business Name That Goes On And On And On\",\"tax_id\":\"123456789012345\",\"registration_number\":\"REG123456789012345\",\"address\":\"123 Very Long Street Name, Suite 1000, Very Long City Name, Very Long State Name, 12345-6789\",\"phone\":\"+1234567890123456\",\"email\":\"verylongemailaddress@verylongdomainname.example.com\",\"additional_info\":\"This is additional information that makes the KYC data even longer to test handling of large data payloads in the smart contract storage system.\"}"
    );

    client.submit_kyc_application(&business, &long_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, long_data);
}

// ============================================================================
// Verification Metadata Tests
// ============================================================================

#[test]
fn test_verified_by_field_set_correctly() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    // Verify the admin who verified is recorded
    assert_eq!(verification.verified_by, Some(admin));
}

#[test]
fn test_rejection_reason_stored_correctly() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Missing tax documentation and business license");

    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    assert_eq!(verification.rejection_reason, Some(rejection_reason));
}

#[test]
fn test_submitted_at_timestamp_non_zero() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Set ledger timestamp
    env.ledger().with_mut(|li| li.timestamp = 1000000);

    client.submit_kyc_application(&business, &kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    assert!(verification.submitted_at >= 1000000);
}

// ============================================================================
// Business Verification Status Enum Tests
// ============================================================================

#[test]
fn test_status_transitions_pending_to_verified() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    client.submit_kyc_application(&business, &kyc_data);

    // Check initial status is Pending
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Pending));

    client.verify_business(&admin, &business);

    // Check status changed to Verified
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Verified));
}

#[test]
fn test_status_transitions_pending_to_rejected() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    client.submit_kyc_application(&business, &kyc_data);

    // Check initial status is Pending
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Pending));

    client.reject_business(&admin, &business, &rejection_reason);

    // Check status changed to Rejected
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Rejected));
}

#[test]
fn test_status_transitions_rejected_to_pending_on_resubmit() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit -> Reject
    client.submit_kyc_application(&business, &kyc_data);
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify Rejected status
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Rejected));

    // Resubmit
    let new_kyc_data = create_test_kyc_data(&env, "UpdatedBusiness");
    client.submit_kyc_application(&business, &new_kyc_data);

    // Check status changed back to Pending
    let verification = client.get_business_verification_status(&business).unwrap();
    assert!(matches!(verification.status, BusinessVerificationStatus::Pending));
}

// ============================================================================
// Empty List Edge Cases
// ============================================================================

#[test]
fn test_get_verified_businesses_empty_initially() {
    let (env, client, _admin) = setup();

    let verified = client.get_verified_businesses();
    assert_eq!(verified.len(), 0);
}

#[test]
fn test_get_pending_businesses_empty_initially() {
    let (env, client, _admin) = setup();

    let pending = client.get_pending_businesses();
    assert_eq!(pending.len(), 0);
}

#[test]
fn test_get_rejected_businesses_empty_initially() {
    let (env, client, _admin) = setup();

    let rejected = client.get_rejected_businesses();
    assert_eq!(rejected.len(), 0);
}
